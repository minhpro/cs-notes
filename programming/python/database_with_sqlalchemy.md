# Table of contents

- [SQLAlchemy 2.0 propose](#sqlalchemy-20)
- [Convention to work with SQLAlchemy](#database-programming-with-sqlalchemy)
    - [Establishing Connectivity](#establishing-connectivity---the-engine)
    - [Declare Database Metadata](#declare-database-metadata)
    - [Using Core APIs](#using-core-apis)
    - [Using ORM](#using-orm)
    - [Work with raw SQL](#work-with-raw-sql)

# SQLAlchemy 20

Propose to upgrade to SQLAlchemy 2.0 to work with database:
- The SQLAlchemy 1.4 is in maintenace state, only supports critical fixs.
- SQLAlchemy 2.0 releases in January 2023 and is the current version.
- The version 2.0 takes some improvements:
    - Clearer and unified query APIs.
    - Make it to work with both Core APIs and ORM easier.
    - Typing improvements: use typing hints to declare columns and relationships in models. This takes some benefits:
        - Interating with typing tools, like mypy.
        - Interating with Python dataclasses too.
        - Having a strongly typed model will help your IDE, improve your coding experience, and reduce some typed bugs.
    - Strong support asynchronous to work with databases - asynio extension(Version 1.4 introduced a beta version of the asynio extension).

Reading:
- https://docs.sqlalchemy.org/en/20/changelog/whatsnew_20.html
- https://blog.miguelgrinberg.com/post/what-s-new-in-sqlalchemy-2-0

# Database programming with SQLAlchemy 

There are three primary ways to use SQLAlchemy to work with the database:
- Using Core APIs (SQLAlchemy Expression Language)
- Using ORM
- Using raw SQL statement

Depending on your tasks, you can use raw SQLs with SQLAlchemy in cases of complex queries, or special queries, but prefer using Core APIs and ORM to work with other cases.

Before to work with the database, first, we have to configure the connection to it.

## Establishing Connectivity - the Engine

SQLAlchemy `Engine` object provides a factory as well as a holding space called a `connection pool` for database connections:

```python
import sqlalchemy as sa
from .config import setting

db_url = sa.URL.create(
    drivername="postgresql+psycopg",
    username=setting.db_user,
    password=setting.db_password,
    host=setting.db_host,
    database=setting.db_name,
)

engine = sa.create_engine(db_url)
Session = so.sessionmaker(engine) # to work with ORM
```

## Declare Database Metadata

To using the SQLAlchemy Core APIs or ORM, we have to declare the database metadata such as: `Metadata`, `Table`, and `Column` objects.

In SQLAlchemy, the database "table" is represented by a Python object named `Table`.

**Create a metadata object**

```python
import sqlalchemy as sa
metadata_obj = sa.Metadata()
```

**Declare Table directly**

Once we have a `Metadata` object, we can declare some `Table` objects.

```python
import sqlalchemy as sa

user_table = Table(
    "users",
    metadata_obj,
    sa.Column("id", sa.Integer, primary_key=True),
    sa.Column("name", sa.String(30)),
    sa.Column("fullname"), sa.String
)
```

**Declare Table metadata by using ORM Mapped classes**

To declare Table with ORM Mapped classes, we will extend a `DeclarativeBase` class.

```python
import sqlalchemy as sa
import sqlalchemy.orm as so

class Model(so.DeclarativeBase):
    metadata = metadata_obj

class User(Model):
    __table_name__ = "users"

    id: so.Mapped[int] = so.mapped_column(primary_key=True)
    name: so.Mapped[str] = so.mapped_column(sa.String(30))
    fullname: so.Mapped[str] = so.mapped_column(sa.String)
```

Reading:
- https://docs.sqlalchemy.org/en/20/tutorial/metadata.html

## Using Core APIs

To use the SQLAlchemy Core APIs:
- Constructing the Statement object
- Using `engine` to get the connection
- Executing the Statement object by the connection and get the result

Take an example of INSERT statement:

A INSERT statement is generated by using `sqlalchemy.insert()` function. This function generates an instance of `Insert` which represents an INSERT statement in SQL.

```python
import sqlalchemy as sa
stmt_obj = sa.insert(user_table).values(name="abc", fullname="xyz")
print(type(stmt_obj))
print(stmt_obj)
# <class 'sqlalchemy.sql.expression.Insert'>
# INSERT INTO users (name, fullname) VALUES (:name, :fullname)
```

Then, executing the Statement (using `engine.connect()` to generate a connection to the database)

```python
with engine.connect() as conn:
    result = conn.execute(stmt)
    conn.commit()
```

Reading:
- https://docs.sqlalchemy.org/en/20/tutorial/data.html

## Using ORM

While work with Core API, we use the `engine.connect()` to execute the statement, with the ORM, we use the `Session` to work with data.

### Inserting Rows with ORM

When using the ORM, the `Session` object is responsible for constructing `Insert` constructs and emitting them as INSERT statements within the ongoing transaction. The `Session` makes sure these new entries will be emitted to the database when they are needed, using a process known as a `flush`. The process used by the `Session` to persist objects is known as the [**unit of work**](https://docs.sqlalchemy.org/en/20/glossary.html#term-unit-of-work) pattern.

See an example how to add an object to the session

```python
user = User(name="abc", fullname="xyz")
with Session() as session:
    session.add(user)
    session.commit()
```

### Update ORM Objects

When using ORM, an UPDATE statement is emitted automatically  on a per-primary key basis corresponding to individual object that have changes on them.

```python
with Session() as session:
    sandy = session.excute(sa.select(User).filter(User.name == "sandy")).scalar_one()
    print(sandy) # User(id=2, name='sandy', fullname="Sandy Cheeks")
    sandy.fullname = "Sandy Squirrel"
    sandy in session.dirty # True
    sandy_fullname = session.execute(sa.select(User.fullname).where(User.id == 2)).scalar_one()
    print(sandy_fullname) # Sandy Squirrel
    # UPDATE users SET fullname=? WHERE users.id = ?
    # [...] ('Sandy Squirrel', 2)
    # SELECT users.fullname
    # FROM users
    # WHERE users.id = ?
    # [...] (2,)
```

We can see above that we requested the `Session` execute a single `select()` statement. However the SQL emitted shows that an UPDATE were emitted as well. This flush occurs automatically before we emit an SELECT - called **autoflush** behavior.

### Deleting ORM Objects

```python
with Session() as session:
    patrick = session.get(User, 3)
    session.delete(patrick)
```

Reading:
- https://docs.sqlalchemy.org/en/20/tutorial/orm_data_manipulation.html

# Work with raw SQL

We can use the raw SQL with SQLAlchemy by using `text` function to generate a `TextClause` instance and then be executed by `engine.connect().execute()` and return a `CursorResult`.

```python
stmt = sa.text("SELECT * FROM users")
with engine.connect() as conn:
    cursor_result = conn.execute(stmt)
    # fetching result by one of following methods
    # result = cursor_result.fetchall()
    result = cursor_result.fetchmany()
    # ...
    for r in result:
        # Iterate over the result
        # r is type of `sqlalchemy.engine.row.Row`
        # there are some useful information with Row, such as
        # r._asdict, r._mapping, t.tuple()
        print(r)
insert_stmt = sa.text("INSERT INTO users(name, fullname) VALUES(:name, :fullname)")
data = [
    {"name": "user1", "fullname": "User 1"},
    {"name": "user2", "fullname": "User 2"},
]
with engine.connect() as conn:
    for line in data:
        conn.execute(insert_stmt, **line)
```

# Reading

- https://docs.sqlalchemy.org/en/20/index.html
- https://docs.sqlalchemy.org/en/20/tutorial/data.html
- https://docs.sqlalchemy.org/en/20/core/sqlelement.html
- Python DB-API: https://peps.python.org/pep-0249/
- https://blog.miguelgrinberg.com/post/what-s-new-in-sqlalchemy-2-0
- https://github.com/sqlalchemy/sqlalchemy/discussions/10023
- https://www.sqlalchemy.org/download.html#relstatus
