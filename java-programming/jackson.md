## Jackson deserialization

#Using fastxml.jackson version 2.12.1

By default Jackson will use a no args constructor and setters to create the desired instance.

@JsonCreator annotation used for indicating that a constructor or static factory method should be used for creating value instances during deserialization.

We can use a @JsonCreator and @JsonProperty to indicate what constructor Jackson needs to use and how to map properties.

We will discuss the ways to deserialize a String to an Object.

**Solution 0**

Using the default constructor (no args constructor) and setters (or getters are ok, because A Getter Makes a Non-Public Field Serializable and Deserializable. A Setter Makes a Non-Public Field Deserializable Only).

```Java
public class Item {
    private String name;
    private int value;

    // Solution 0: using the default constructor (no arguments) and setters
    // Setters can be generated be @Setter annotation of the Lombok
    public void setName(String name) {
        this.name = name;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public static void main(String[] args) {
        ObjectMapper objectMapper = new ObjectMapper();
       String json = "{\"name\": \"Test\", \"value\": 20}";
       try {
           Item item = objectMapper.readValue(json, Item.class);
           System.out.println(item);
       } catch (JsonProcessingException e) {
           e.printStackTrace();
       }
    }
}
```

**Solution 1**

Using constructor properties

```Java
public class Item {
    private String name;
    private int value;

   // Solution 1: using constructor properties
   @ConstructorProperties({"name", "value"})
   public Item(String name, int value) {
       this.name = name;
       this.value = value;
   }
}
```

The old Lombok (before 16.20) Constructor annotations (like @AllArgsContructor) will generate a constructor with a @ContructorProperties by the default. To make this feature available in the new Lombok, you have to add these properties to `lombok.config` file (place it at the root of your project).

```properties
lombok.addLombokGeneratedAnnotation = true
lombok.anyConstructor.addConstructorProperties = true
```

**Solution 2**

Using JsonCreator and JsonProperty on a constructor or static factory method (public or private are both ok)

```Java
@JsonCreator
private Item(@JsonProperty("name") String name, @JsonProperty("value") int value) {
    this.name = name;
    this.value = value;
}
```

OR static factory method

```Java
@JsonCreator
public static Item of(@JsonProperty("name") String name, @JsonProperty("value") int value) {
    return new Item(name, value);
}

private Item(String name, int value) {
    this.name = name;
    this.value = value;
}
```

**Solution 3**

Using JsonDeserialize annotation and a Builder

```Java
@JsonDeserialize(builder = Item.ItemBuilder.class)
public class Item {
    private String name;
    private int value;

    private Item(String name, int value) {
        this.name = name;
        this.value = value;
    }

    static class ItemBuilder {
        // ...

        public Item build() {
            return new Item(name, value);
        }
    }
}
```

## Using with Lombok annotation

If @AllArgsConstructor or @Value is used (Immutable class), the class will have no a default constructor.

* If class have the setters or getters, we can use Solution 0 by add @NoArgsConstructor(force = true, access = AccessLevel.PRIVATE) annotation to construct a private default constructor. Be careful, @NoArgsConstructor overrides the constructor generated by the @Value, you may need to add the @AllArgsConstructor. 
* Or can use Solution 1 by adding a static factory method with @JsonCreator and @JsonProperty
* Or using Solution 4 with @Builder (Lombok will automatically generate a Builder class for our class) and @JsonDeserialize.
